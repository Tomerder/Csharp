///////////////////////////////////////////////////////////
//  TelnetWrapper.cs
//  Implementation of the Class TelnetWrapper
//  Generated by Enterprise Architect
//  Created on:      28-אוקטובר-2009 14:23:20
//  Original author: dp24450
///////////////////////////////////////////////////////////




using Thought.Net.Telnet;
using System.IO;
using System.Text;
using System.Net.Sockets;
using System.Collections.Generic;
using System.Net;
using System;
using System.Threading;
using System.Net.NetworkInformation;
using System.Timers;
//using MLA.BL.Data;




namespace HWconfig
{


    /// <summary>
    /// Delegate for a method that reads reply from Telnet
    /// </summary>
    /// <returns></returns>
    delegate void ReplyReaderDelegate();


	/// <summary>
	/// Definition
	/// This class implements the Command interface between the local PC and
    /// a remote disk.
    /// 
	/// Role
	/// The role of this class is to encapsulate the object which actually implements
    /// the command interface. This object is of type Thought.Net.Telnet.
    /// A user of this class is not aware of the Telnet library which is encapsulated
    /// by the CmdIntMngr class.
    ///
	/// Responsibility
	/// This class is responsible for performing communication with remote disk in order
    /// to implement the command interface. Communication is done by activating the 
    /// TelnetClient object.
    /// 
    /// This class uses a 3rd party library which might throw exceptions.
    /// In order to keep track of the exceptions that might be thrown in the application,
    /// all Exceptions from 3rd party lib will be caught by methods of this class and the public
    /// methods of this class will return boolean indication regarding their success or failure.
    ///
	/// </summary>
	public class CmdIntMngr: IDisposable
    {
        #region Class Members

        private bool _isDisposed = false;


        /// <summary>
        /// username for establishing telnet connection
        /// </summary>
        private string _uname;

        /// <summary>
        /// password for establishing telnet connection
        /// </summary>
        private string _pass;


        /// <summary>
        /// Class which is responsible for the Telnet protocol implementation
        /// </summary>
        private TelnetClient _telClient = null;


        /// <summary>
        /// Socket for communicating with remote disk
        /// </summary>
        private Socket _socket;


        /// <summary>
        /// IP address of remote disk
        /// </summary>
        private string _ipAddress;

      
        /// <summary>
        /// StreamReader for reading message from telnet server
        /// </summary>
        private StreamReader _reader;


        /// <summary>
        /// StreamReader for writing message to telnet server
        /// </summary>
        private StreamWriter _writer;


        /// <summary>
        /// Indication if there is currently Telnet connection
        /// </summary>
        private bool _isConnected = false;

      
        // Delimiter for parsing a telnet message which arrives 
        // from remote disk
        private static readonly string[] _delim = { "\r\n" };
        
        
        /// <summary>
        /// String inside reply from telnet server which indicates success in executing
        /// a command
        /// </summary>
        private const string _successIndication = "value = 0 = 0x0";

        /// <summary>
        /// Number or tries in case an operation fails
        /// </summary>
       // private  const int _retriesCount = 2;
        private const int _retriesCount = 1;


        // Create a timer that will raise an event every 1 second
        private System.Timers.Timer _telnetReplyTimer;

        /// <summary>
        /// Elapsed time for waiting for Telnet reply
        /// </summary>
        private UInt16 _waitingCounter;

        /// <summary>
        /// timeout for waiting for Telnet reply
        /// </summary>
        private const UInt16 _waitCounterTimeout = 50;



        private object _readThdLocker;
        private Thread _readThread = null;
        private char[] _replyBuffer;
        private string _replyString = null;
        private int _replyLen;

        /// <summary>
        /// Flag which indicates whether a telnet reply has arrived, 
        /// and if it is valid or not
        /// </summary>
        private bool? _after;

        /// <summary>
        /// Locker object for _after variable
        /// </summary>
        private object _afterLocker;

        private ReplyReaderDelegate _del;

        #endregion


        #region Constructor

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="ip">string, IP, remote ip address</param>
        /// <param name="uname">string, IN, username for connecting to telnet server</param>
        /// <param name="password">string, IN, password for connecting to telnet server</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// Assign class members with given arguments
        /// </AlgorithmsAndLogicFlow>
        internal CmdIntMngr(string ip, string uname, string password)
        {
            _ipAddress = ip;
            _uname = uname;
            _pass = password;

            _replyBuffer = new char[2000];

            _after = null;

            _readThdLocker = new object();
            _afterLocker = new object();
        }


     
        ~CmdIntMngr()
        {
           
            Dispose(false);
           
        }

        #endregion



        private void InitReplyTimer()
        {
            _telnetReplyTimer = new System.Timers.Timer(500);
            _telnetReplyTimer.AutoReset = true;
            _telnetReplyTimer.Elapsed += new ElapsedEventHandler(_telnetReplyTimer_Elapsed);
            ////MlaLogger.Instance.Write("@@@@@@@@@@@ from InitReplyTimer()");
        }
       

        /// <summary>
        /// Read a reply from the Telnet server.
        /// Exit the thread after read operation is completed.
        /// </summary>
        private void ReplyReaderFunc()
        {
            ////MlaLogger.Instance.Write("FROM ReplyReaderFunc", LogLevelEnum.INFO);

            string strErr;
            
            bool conn = Connect(out strErr);
            if (conn)
            {

                try
                {
                    _replyLen = 0;
                    _replyString = null;
                    //MlaLogger.Instance.Write("#### before read #####", LogLevelEnum.DEBUG);

                    _replyLen = _reader.Read(_replyBuffer, 0, _replyBuffer.Length);
                    //MlaLogger.Instance.Write("############ AFTER READ   ##########", LogLevelEnum.DEBUG);
                    _replyString = new string(_replyBuffer, 0, _replyLen);

                    //MlaLogger.Instance.Write("ReplyReaderFunc(): ******** _replyString = " + _replyString + ", len = " + _replyLen.ToString(),LogLevelEnum.DEBUG);
                    lock (_afterLocker)
                    {
                        _after = true;
                    }
                    //MlaLogger.Instance.Write("ReplyReaderFunc(): ^^^^^^^^^^^ setting _after to " + _after.ToString(), LogLevelEnum.DEBUG);


                }
                catch (ThreadAbortException)
                {
                    //MlaLogger.Instance.Write("ReplyReaderFunc(): Caught Abort Exception", LogLevelEnum.WARNING);
                    lock (_afterLocker)
                    {
                        _after = false;
                    }
                    //MlaLogger.Instance.Write("ReplyReaderFunc(): ^^^^^^^^^^^ setting _after to " + _after.ToString(), LogLevelEnum.DEBUG);
                }
                catch (Exception ex1)
                {
                    //MlaLogger.Instance.Write("ReplyReaderFunc(): Caught Exception: " + ex1.Message, LogLevelEnum.ERROR);
                    lock (_afterLocker)
                    {
                        _after = false;
                    }
                    //MlaLogger.Instance.Write("ReplyReaderFunc(): ^^^^^^^^^^^ setting _after to " + _after.ToString(), LogLevelEnum.DEBUG);
                }


            }
            else
            {
                //MlaLogger.Instance.Write(string.Format("ReplyReaderFunc(): Problem in connecting: {0}", strErr), LogLevelEnum.ERROR);
            }

            //MlaLogger.Instance.Write("ReplyReaderFunc(): Exiting ReplyReaderFunc", LogLevelEnum.INFO);
    
        }



        /// <summary>
        /// Dispose managed/unmanaged resources of the object
        /// </summary>
        /// <param name="disposing"></param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// If the value of 'disposing' is true, the object will free both 
        /// managed and unmanaged resources.
        /// If the value is false, this method was called from the finalizer 
        /// (destructor) so it should free only managed resources.
        /// </AlgorithmsAndLogicFlow>
        protected virtual void Dispose(bool disposing)
        {
            // if this object was not disposed yet
            if (!_isDisposed)
            {
                if (disposing)
                {
                    // free managed resources
                }


                // free unmanaged resources


                if (_telClient != null)
                {
                    if (_isConnected)
                    {
                        _telClient.Close();

                        _telnetReplyTimer.Stop();
                        _telnetReplyTimer.Dispose();

                        //MlaLogger.Instance.Write("@@@@@@@@@@@ AFTER _telnetReplyTimer stop and dispose");

                        if (_readThread != null)
                        {
                            _readThread.Abort();
                            _readThread.Join();
                            //MlaLogger.Instance.Write("_readThread ended", LogLevelEnum.DEBUG);
                        }



                        _isConnected = false;
                    }


                    _reader.Dispose();
                    _writer.Dispose();
                    _socket.Dispose();
                }

                // Set the flag to indicate that object was disposed
                _isDisposed = true;

            }
        }


        #region IDisposable Members

        /// <summary>
        /// This method should be called explicitly in order to free
        /// managed and unmanaged resources.
        /// </summary>
        public void Dispose()
        {
           
            //MlaLogger.Instance.Write("From CmdIntMngr.Dispose()", LogLevelEnum.DEBUG);

            // Call dispose for freeing manages and unmanaged resources
            Dispose(true);

            //Request the system to not call the finalizer for this object
            GC.SuppressFinalize(this);
           
        }

        #endregion
      
        #region Public Methods


        /// <summary>
        /// Send all messages via Telnet 
        /// </summary>
        /// <param name="commands"></param>
       /*public string SendTelnetCommands(List<MLA.config.SingleTelnetCommand> commands)
        {
            string errMsg = string.Empty;
            StringBuilder builder = new StringBuilder();
            if ((commands != null) && (commands.Count > 0))
            {
                string singleErr = null;
                foreach (MLA.config.SingleTelnetCommand cmd in commands)
                {
                    SendSingleCmd(cmd.Command, out singleErr);
                    if ((singleErr != null) && (singleErr.Length>0))
                    {
                        singleErr = string.Format("Failed sending command: {0}. Problem: {1}",
                                            cmd.Command, singleErr);
                        builder.AppendLine(singleErr);
                    }
                }
            }

            if (builder.Length > 0)
            {
                errMsg = builder.ToString();
            }

            return errMsg;
        }*/

        /// <summary>
        /// Send a single message via Telnet
        /// </summary>
        /// <param name="cmd">string, IN, message to send</param>
        /// <param name="errmsg">string, OUT, returned error message, in case of failure </param>
        public void SendSingleCmd(string cmd, out string errmsg)
        {
            errmsg = null;
            try
            {
                
                bool conn = Connect(out errmsg);
                if (conn)
                {
                    Console.WriteLine("Telnet success!!!"); 

                    //MlaLogger.Instance.Write("SendSingleCmd(): CMD = " + cmd, LogLevelEnum.DEBUG);

                    // Send the command via Telnet
                    bool ok = SendTelnetCommand(cmd);

                    //MlaLogger.Instance.Write("SendSingleCmd(): after SendTelnetCommand(). ok = " + ok.ToString(), LogLevelEnum.DEBUG);
                    if (!ok)
                    {
                        //MlaLogger.Instance.Write("SendSingleCmd(): Failed sending command", LogLevelEnum.ERROR);
                    }
                    else
                    {
                        // Read Telnet reply
                        string result = ReadTelnetReply();

                        Console.WriteLine("Telnet Reply : " + result); 

                        //MlaLogger.Instance.Write("SendSingleCmd(): Result: " + result);


                        // Stop the timer
                        //MlaLogger.Instance.Write("SendSingleCmd(): BEFORE stopping the timer", LogLevelEnum.DEBUG);
                        _telnetReplyTimer.Stop();
                        //MlaLogger.Instance.Write("SendSingleCmd(): AFTER stopping the timer", LogLevelEnum.DEBUG);


                        // In case the reply is valid, set the boolean indication to true
                        ok = CmdIntMngr.IsResultValid(result);
                        if (ok)
                        {
                            //MlaLogger.Instance.Write("SendSingleCmd(): Telnet result is valid", LogLevelEnum.INFO);
                        }
                        else
                        {
                            //MlaLogger.Instance.Write("SendSingleCmd(): Telnet result is Invalid", LogLevelEnum.INFO);
                            errmsg = string.Format("{0}\nInvalid result from Telnet Server", errmsg);
                            Disconnect();
                        }
                    }
                }
                else
                {
                    Console.WriteLine("Telnet connect failed!!!"); 
                }
            }

            catch (Exception ex)
            {
                errmsg = string.Format("{0}\n{1}", errmsg, ex.Message);
                //MlaLogger.Instance.Write(errmsg, LogLevelEnum.ERROR);
                Disconnect();
            }

        }

     
        #endregion


        #region Helper Methods

     
        /// <summary>
        /// Check if a result returned from remote disk command is valid
        /// </summary>
        /// <param name="result">string, IN, result to check</param>
        /// <returns>Indication of valid or not</returns>
        /// <ErrorHandlingAndLimitations>
        /// Validate argument
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// Check if the error indication phrase is contained inside the result string.
        /// If so, return false. Else, return true.
        /// </AlgorithmsAndLogicFlow>
        private static bool IsResultValid(string result)
        {
            bool ret = false;
            if (result != null)
            {
                // Parse result for checking if operation completed successfully
                string[] lines = result.Split(_delim, StringSplitOptions.RemoveEmptyEntries);
                //MlaLogger.Instance.Write("IsResultValid(): lines count = " + lines.Length);
                if (lines.Length >=3)
                {
                  
                    // if the checked line contains this string it indicates an error
                    ret = lines[2].Contains(_successIndication);
                }
            }
            return ret;

        }


        /// <summary>
        /// This method is called from the Connect() method and its purpose is
        /// to send username and password to the Telnet server in case they are defined.
        /// </summary>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// </AlgorithmsAndLogicFlow>
        private void ConnectTelnetServer()
        {
            StringBuilder receivedMsg = new StringBuilder();

            if ((_uname != null) && (_uname.Length > 0) &&
                (_pass != null) && (_pass.Length > 0))
            {

                // Send username and password:
                char[] chars = new char[1000];
                int totalRead = 0;
                string str;
                bool afterpass = false;
         
                try
                {
                    // read into buffer
                    totalRead = _reader.Read(chars, 0, chars.Length);
                    receivedMsg.Append(chars, 0, totalRead);
                    str = receivedMsg.ToString();
                    if (str.Contains("login"))
                    {
                        // send username
                        _writer.Write(_uname + "\r\n");
                        receivedMsg.Remove(0, receivedMsg.Length);
                    }
                    else if (str.Contains("password"))
                    {
                        // send password
                        _writer.Write(_pass + "\r\n");
                        receivedMsg.Remove(0, receivedMsg.Length);
                        afterpass = true;
                    }
                    else
                    {
                        if (afterpass)
                        {
                            _isConnected = true;
                        }
                    }

                }
                catch (Exception)
                {
                    _isConnected = false;
                }
            }
            else
            {
                _isConnected = true;
            }
        }


        /// <summary>
        /// Connect to remote Telnet server
        /// </summary>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// if _isConnected equals false, it means that not connected
        /// to server yet.
        /// In this case:
        /// Call MlaGenDefs.IsRemoteAlive() to check if there is ping to the remote server.
        /// If yes,
        ///     Create a Socket with IP address of remote disk.   
        ///     Set the socket's ReceiveTimeout value to 5 seconds.
        ///     Connect the socket to port 23.  
        ///     Initialize the _telClient member.
        ///     Set the event handlers for all the types of event that may be raised
        ///     by the telnet client object.
        ///     Create a TelnetStream object using the telnet client object.
        ///     Create a StreamReader and a StreamWriter objects using the created TelnetStream.
        ///     Call ConnectTelnetServer() in order to connect with username and password
        ///  
        /// If anything went wrong or an Exception was caught, set _isConnected to false.
        /// Else set it to true.
        /// 
        /// try to connect up to 2 times
        /// </AlgorithmsAndLogicFlow>
        private bool Connect(out string errmsg)
        {
            
            errmsg = null;
            
            // if not connected already
            if (!_isConnected)
            {
                
                PingReply pingReply;
                int count = 0;

                // Try to connect as long as try fails and there
                // are more retries
                while ((!_isConnected) && (count < _retriesCount))
                {
                    try
                    {

                        //MlaLogger.Instance.Write(string.Format("CmdIntMngr.Connect(): Try connecting to TELNET server {0}", _ipAddress));


                        InitReplyTimer();

                        // Check if there is Ethernet communication with target
                        //if (MlaGenDefs.IsRemoteAlive(_ipAddress, out pingReply))
                        {

                            //MlaLogger.Instance.Write(string.Format("CmdIntMngr.Connect(): Receivied PING reply from server {0}", _ipAddress));

                            // Create an Internet (IP) socket for the TCP protocol.
                            _socket = new Socket(AddressFamily.InterNetwork,
                                                        SocketType.Stream,
                                                        ProtocolType.Tcp);


                            // Limit the time to wait for response to 10 minutes
                            _socket.ReceiveTimeout = (int)(600000);//(int)(MlaGenDefs.TcpRecvTimeout); // 600000


                            // Connect to remote target : ip , port
                            _socket.Connect(_ipAddress, 23);

                            // Create a new instance of the TelnetClient class.
                            _telClient = new TelnetClient(_socket);

                            // set event handlers
                            _telClient.CommandReceived += new TelnetCommandEventHandler(telClient_CommandReceived);
                            _telClient.DontReceived += new TelnetOptionEventHandler(telClient_DontReceived);
                            _telClient.DoReceived += new TelnetOptionEventHandler(telClient_DoReceived);
                            _telClient.WillReceived += new TelnetOptionEventHandler(telClient_WillReceived);
                            _telClient.WontReceived += new TelnetOptionEventHandler(telClient_WontReceived);


                            // read /write data from socket 
                            TelnetStream stream = new TelnetStream(_telClient);

                            // Create StreamReader for reading message from telnet server
                            _reader = new StreamReader(stream);

                            // Create StreamWriter for sending messages to telnet server
                            _writer = new StreamWriter(stream);
                            _writer.AutoFlush = true;

                            // Connect with username and password
                            ConnectTelnetServer();
                        }
                        //else
                        //{
                        //   errmsg = string.Format("Reply from ping to {0} is: {1}", _ipAddress, pingReply.Status);
                        //}
                    }
                    catch (Exception ex)
                    {
                        //MlaLogger.Instance.Write(string.Format("CmdIntMngr.Connect(): Problem connecting to Telnet server on {0}: {1}",_ipAddress, ex.Message),LogLevelEnum.ERROR);
                        _isConnected = false;
                        errmsg = ex.Message;
                    }
  
                    count++;
                 }
               
            }
            

            if (_isConnected)
            {
                //MlaLogger.Instance.Write(string.Format("Connect(): Succeeded connecting to Telnet server {0}", this._ipAddress),LogLevelEnum.DEBUG);
            }
            else
            {
                // Set the final error message and error code
                errmsg = string.Format("DataIntMngr.Connect(): Failed connecting to Telnet server: {0}", errmsg);
                //MlaLogger.Instance.Write(errmsg, LogLevelEnum.ERROR);
            }

            return _isConnected;
        }

        /// <summary>
        /// Disconnect from remote server
        /// </summary>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// Call the Dispose() method.
        /// Set _isConnected to false.
        /// </AlgorithmsAndLogicFlow>
        internal void Disconnect()
        {
            //MlaLogger.Instance.Write("from CmdIntMngr.Disconnect()", LogLevelEnum.INFO);
           // this.Dispose();
            if (_isConnected)
            {

                _telClient.Close();
                _telnetReplyTimer.Stop();

                //MlaLogger.Instance.Write("@@@@@@@@@@@ AFTER _telnetReplyTimer stop and dispose");

                if (_readThread != null)
                {
                    _readThread.Abort();
                    _readThread.Join();
                    //MlaLogger.Instance.Write("_readThread ended", LogLevelEnum.DEBUG);
                }



                _isConnected = false;
            }
        }


        /// <summary>
        /// Event handler for handling events raised by the telnet client
        /// when a command arrives from server
        /// </summary>
        /// <param name="sender">object, IN, sender</param>
        /// <param name="e">TelnetCommandEventArgs, IN, event args</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// nothing to do.
        /// </AlgorithmsAndLogicFlow>
        private void telClient_CommandReceived(object sender, TelnetCommandEventArgs e)
        {
            // UpdateScreen("Client: Received command: " + e.Command.ToString() + '\n');
        }

        /// <summary>
        /// Event handler for handling events raised by the telnet client
        /// when a WONT messages arrives from server
        /// </summary>
        /// <param name="sender">object, IN, sender</param>
        /// <param name="e">TelnetCommandEventArgs, IN, event args</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// if the received TelnetOption is Echo, set the Agreed flag of the event args to true.
        /// </AlgorithmsAndLogicFlow>
        private void telClient_WontReceived(object sender, TelnetOptionEventArgs e)
        {
            // UpdateScreen("Client: Received WONT: " + e.Command.ToString() + '\n');
            if (e.Option == TelnetOption.Echo)
            {
                //The server sent a WONT ECHO command.  This means
                //it refuses to continue echoing typed characters.
                e.Agreed = true;
                // _localEcho = true;
            }

        }

        /// <summary>
        /// Event handler for handling events raised by the telnet client
        /// when a WILL message arrives from server
        /// </summary>
        /// <param name="sender">object, IN, sender</param>
        /// <param name="e">TelnetCommandEventArgs, IN, event args</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// if the received TelnetOption is Echo, set the Agreed flag of the event args to true.
        /// </AlgorithmsAndLogicFlow>
        private void telClient_WillReceived(object sender, TelnetOptionEventArgs e)
        {
            //  UpdateScreen("Client: Received WILL: " + e.Command.ToString() + '\n');
            if (e.Option == TelnetOption.Echo)
            {
                //The server sent a WILL ECHO command.  This means the
                //server is willing to ECHO typed characters (instead of
                //the local client doing so).  This is a common option 
                //because the server can then fully control the output
                //of typed characters.

                //This client agrees to let the server handle echoing.
                //Local echoing is turned off.

                e.Agreed = true;
                // _localEcho = false;

            }
        }

        /// <summary>
        /// Event handler for handling events raised by the telnet client
        /// when a DO message arrives from server
        /// </summary>
        /// <param name="sender">object, IN, sender</param>
        /// <param name="e">TelnetCommandEventArgs, IN, event args</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// Nothing to do.
        /// </AlgorithmsAndLogicFlow>
        private void telClient_DoReceived(object sender, TelnetOptionEventArgs e)
        {
            //  UpdateScreen("Client: Received DO: " + e.Command.ToString() + '\n');
        }

        /// <summary>
        /// Event handler for handling events raised by the telnet client
        /// when a DONT message arrives from server
        /// </summary>
        /// <param name="sender">object, IN, sender</param>
        /// <param name="e">TelnetCommandEventArgs, IN, event args</param>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// Nothing to do.
        /// </AlgorithmsAndLogicFlow>
        private void telClient_DontReceived(object sender, TelnetOptionEventArgs e)
        {
            // UpdateScreen("Client: Received DONT: " + e.Command.ToString() + '\n');
        }

      

        private void StartReplyWaitingTimer()
        {
            _waitingCounter = 0;
            _telnetReplyTimer.Start();
            //MlaLogger.Instance.Write("AFTER _telnetReplyTimer start", LogLevelEnum.DEBUG);
        }





        /// <summary>
        /// Send a command to telnet server on the remote disk.
        /// Return a string containing the reply which arrived
        /// from telnet server.
        /// </summary>
        /// <param name="command">string, IN, command to send</param>
        /// <returns>the returned string from Telnet server</returns>
        /// <ErrorHandlingAndLimitations>
        /// </ErrorHandlingAndLimitations>
        /// <AlgorithmsAndLogicFlow>
        /// TBD
        /// </AlgorithmsAndLogicFlow>
        private bool SendTelnetCommand(string command)
        {
            bool ok = false;


            //MlaLogger.Instance.Write("---- from SendTelnetCommand(): " + command, LogLevelEnum.INFO);

            string strErr;
            bool conn = Connect(out strErr);
            if (conn)
            {
                try
                {
                    // Send the command to Telnet server
                    //MlaLogger.Instance.Write("SendTelnetCommand(): Before Write", LogLevelEnum.INFO);
                    _writer.Write(command + "\r\n");
                    //MlaLogger.Instance.Write("SendTelnetCommand(): After Write", LogLevelEnum.INFO);

                    // Wait for few seconds
                    Thread.Sleep(3000);

                    ok = true;

                }
                catch (Exception ex)
                {
                    //MlaLogger.Instance.Write("SendTelnetCommand(): Caught Exception: " + ex.Message, LogLevelEnum.ERROR);
                }
            }
            else
            {
                //MlaLogger.Instance.Write(string.Format("SendTelnetCommand(): Problem in connecting: {0}", strErr), LogLevelEnum.ERROR);
            }

            return ok;
        }


        /// <summary>
        /// This method tries to read from Telnet
        /// </summary>
        private void ReadTelnetReplyDel()
        {
           
            lock (_readThdLocker)
            {

                // Start the Timer that checks if the Read operation completed
                // (this is in order to know when the thread that reads should abort).
                StartReplyWaitingTimer();
                //MlaLogger.Instance.Write("Read2(): After StartReplyWaitingTimer", LogLevelEnum.DEBUG);

                // Run the thread that tries to read from Telnet server.
                // This method will set the read message inside a member variable.
                _readThread = new Thread(ReplyReaderFunc);
                _readThread.Start();
               

                
            }
        }

        private string ReadTelnetReply()
        {
            // Init the flag that indicates 
            _after = null;

            //MlaLogger.Instance.Write("ReadTelnetReply(): ^^^^^^^^^^^ setting _after to NULL", LogLevelEnum.DEBUG);

            // initiate the delegate method
            _del = new ReplyReaderDelegate(ReadTelnetReplyDel);


            // Invoke the method asynchronously
            IAsyncResult result = _del.BeginInvoke(null, null);
            Thread.Sleep(2000);
            //MlaLogger.Instance.Write("ReadTelnetReply(): After _del.BeginInvoke() and Sleep 2 seconds", LogLevelEnum.DEBUG);

            _del.EndInvoke(result);
            //MlaLogger.Instance.Write("ReadTelnetReply(): After _del.EndInvoke", LogLevelEnum.DEBUG);

            //MlaLogger.Instance.Write("ReadTelnetReply(): _replyString = " + _replyString, LogLevelEnum.DEBUG);
            return _replyString;

        }


        /// <summary>
        /// Method that checks if the read from telnet has already ended.
        /// This method will be running according to the definition in the
        /// _telnetReplyTimer object.
        /// Wach time it runs, it checks if the value of _after is set to true/false.
        /// This is in order to check whether reading from Telnet completed
        /// (successfully or with failure).
        /// In case _after has the value of true/false, this method calls 
        /// AbortReaderOp() for stopping the reader thread.
        /// Otherwise this method does nothing.
        /// In case no true/false value is set to _after after 50 iterations,
        /// we assume that the read operation is stuck so we call AbortReaderOp()
        /// for stopping the reading attempt.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void _telnetReplyTimer_Elapsed(object sender, ElapsedEventArgs e)
        {
            // If a reply has arrived from target then stop the timer
            bool? afterRead;
            lock (_afterLocker)
            {
                afterRead = _after;
            }

            if ((afterRead == true) || 
                (afterRead == false))
            {
                //MlaLogger.Instance.Write("_telnetReplyTimer_Elapsed(): _after is " + _after.ToString(), LogLevelEnum.DEBUG);
                AbortReaderOp();
            }
            else
            {
                // If reply was not received yet, check if passed the timeout,
                // if yes then stop the thread, else let it continue until the next iteration.

                _waitingCounter++;
                //MlaLogger.Instance.Write("_waitingCounter = " + _waitingCounter.ToString(), LogLevelEnum.DEBUG);
                
                if (_waitingCounter >= _waitCounterTimeout)
                {
                    //MlaLogger.Instance.Write(string.Format("_waitingCounter = {0}, _waitCounterTimeout = {1} --> Aborting THD!!!",_waitingCounter, _waitCounterTimeout), LogLevelEnum.INFO);

                    AbortReaderOp();
                }
            }
        }



        private void AbortReaderOp()
        {
            ////MlaLogger.Instance.Write("FROM AbortReaderOp()");
            lock (_readThdLocker)
            {
                ThreadState state = _readThread.ThreadState;
                //MlaLogger.Instance.Write("----------Thread state in AbortReaderOp(): " + state.ToString(), LogLevelEnum.DEBUG);


                // Stop the thread which waits for the reply
                if (state != ThreadState.Unstarted)
                {
                    //MlaLogger.Instance.Write("Reached Timer's timeout, aborting reader thread ", LogLevelEnum.DEBUG);
                    _readThread.Abort();
                    _readThread.Join();
                    //MlaLogger.Instance.Write("AbortReaderOp(): --------------   After _readThread.Join()", LogLevelEnum.DEBUG);

                    //MlaLogger.Instance.Write("Thread stat after join: " + _readThread.ThreadState.ToString(), LogLevelEnum.DEBUG);
                }              
            }
        }
        
        #endregion
 
    
    }//end CmdIntMngr

}//end namespace Comm